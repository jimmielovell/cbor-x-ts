(function(e){"function"==typeof define&&define.amd?define(e):e()})(function(){'use strict';(function(e){"function"==typeof define&&define.amd?define(e):e()})(function(){(function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):(e=e||self,t(e.CBOR={}))})(void 0,function(e){function t(){try{let e=n();if(L==x)// finished reading this source, cleanup references
j=null,C=null,T&&(T=null);else if(L>x){// over read
let e=new Error("Unexpected end of CBOR data");// @ts-ignore
throw e.incomplete=!0,e}else if(!Y)throw new Error("Data read, but end of buffer not reached");// else more to read, but we are reading sequentially, so don't clear source yet
return e}catch(e){throw h(),(e instanceof RangeError||e.message.startsWith("Unexpected end of buffer"))&&(e.incomplete=!0),e}}function n(){let e=C[L++],t=e>>5;if(e&=31,23<e)switch(e){case 24:e=C[L++];break;case 25:if(7==t)return c();e=v.getUint16(L),L+=2;break;case 26:if(7==t){let e=v.getFloat32(L);if(2<M.useFloat32){// this does rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved
let t=ne[(127&C[L])<<1|C[L+1]>>7];return L+=4,(t*e+(0<e?.5:-.5)>>0)/t}return L+=4,e}e=v.getUint32(L),L+=4;break;case 27:if(7==t){let e=v.getFloat64(L);return L+=8,e}M.int64AsNumber?(e=4294967296*v.getUint32(L),e+=v.getUint32(L+4)):e=v.getBigUint64(L),L+=8;break;case 31:// indefinite length
switch(t){case 2:// byte string
case 3:// text string
case 4:// array
let e,s=[],a=0;for(;(e=n())!=F;)s[a++]=e;return 4==t?s:3==t?s.join(""):Buffer.concat(s);case 5:// map
let r;if(M.mapsAsObjects){let e={};for(;(r=l())!=F;)e[r]=n();return e}else{D&&(M.mapsAsObjects=!0,D=!1);let e=new Map;for(;(r=n())!=F;)e.set(r,n());return e}case 7:return F;default:throw new Error("Invalid major type for indefinite length "+t);}default:throw new Error("Unknown token "+e);}switch(t){case 0:// positive int
return e;case 1:// negative int
return~e;case 2:// buffer
return d(e);case 3:// string
if(_>=L)return P.slice(L-V,(L+=e)-V);if(0==_&&140>x&&32>e){// for small blocks, avoiding the overhead of the extract call is helpful
let t=16>e?u(e):o(e);if(null!=t)return t}return $(e);case 4:// array
let a=Array(e);for(let t=0;t<e;t++)a[t]=n();return a;case 5:// map
if(M.mapsAsObjects){let t={};for(let s=0;s<e;s++)t[l()]=n();return t}else{D&&(M.mapsAsObjects=!0,D=!1);let t=new Map;for(let s=0;s<e;s++)t.set(n(),n());return t}case 6:// extension
if(e>>8==S){// record structures
let t=j[255&e];if(t)return t.read||(t.read=s(t)),t.read();if(M.getStructures){let n=p(()=>(C=null,M.getStructures()));return!0===j?M.structures=j=n:j.splice.apply(j,[0,n.length].concat(n)),t=j[255&e],t?(t.read||(t.read=s(t)),t.read()):e}return e}else{let t=w[e];if(t)return t.handlesRead?t(n):t(n());else{let t=n();for(let n,s=0;s<N.length;s++)if(n=N[s](e,t),void 0!==n)return n;return new J(t)}}case 7:// fixed value
switch(e){case 20:return!1;case 21:return!0;case 22:return null;case 23:return;// undefined
case 31:default:let t=B[e];if(void 0!==t)return t;throw new Error("Unknown token "+e);}default:// negative int
if(isNaN(e)){let e=new Error("Unexpected end of CBOR data");// @ts-ignore
throw e.incomplete=!0,e}throw new Error("Unknown CBOR token "+e);}}function s(e){function t(){// This initial function is quick to instantiate, but runs slower. After several iterations pay the cost to build the faster function
if(2<t.count++)return this.read=new Function("a","r","return function(){a();return {"+e.map(e=>q.test(e)?e+":r()":"["+JSON.stringify(e)+"]:r()").join(",")+"}}")(a,n),this.read();a();let r={};for(let t,a=0;a<s;a++)t=e[a],r[t]=n();return r}let s=e.length;return t.count=0,t}function a(){// consume the array header, TODO: check expected length
let e=C[L++];//let majorType = token >> 5
e&=31;23<e&&(24===e?L++:25===e?L+=2:26===e?L+=4:void 0)}function r(e){let t;if(16>e&&(t=u(e)))return t;if(64<e&&E)return E.decode(C.subarray(L,L+=e));const n=L+e,s=[];for(t="";L<n;){const e=C[L++];if(0==(128&e))s.push(e);else if(192==(224&e)){// 2 bytes
const t=63&C[L++];s.push((31&e)<<6|t)}else if(224==(240&e)){// 3 bytes
const t=63&C[L++],n=63&C[L++];s.push((31&e)<<12|t<<6|n)}else if(240==(248&e)){// 4 bytes
const t=63&C[L++],n=63&C[L++],a=63&C[L++];let r=(7&e)<<18|t<<12|n<<6|a;65535<r&&(r-=65536,s.push(55296|1023&r>>>10),r=56320|1023&r),s.push(r)}else s.push(e);4096<=s.length&&(t+=G.apply(String,s),s.length=0)}return 0<s.length&&(t+=G.apply(String,s)),t}function o(e){let t=L,n=Array(e);for(let s=0;s<e;s++){const e=C[L++];if(0<(128&e))return void(L=t);n[s]=e}return G.apply(String,n)}function u(t){if(4>t){if(!(2>t)){let e=C[L++],n=C[L++];if(0<(128&e)||0<(128&n))return void(L-=2);if(3>t)return G(e,n);let s=C[L++];return 0<(128&s)?void(L-=3):G(e,n,s)}if(0===t)return"";else{let e=C[L++];return 1<(128&e)?void(L-=1):G(e)}}else{let s=C[L++],a=C[L++],r=C[L++],u=C[L++];if(0<(128&s)||0<(128&a)||0<(128&r)||0<(128&u))return void(L-=4);if(6>t){if(4===t)return G(s,a,r,u);else{let t=C[L++];return 0<(128&t)?void(L-=5):G(s,a,r,u,t)}}else if(8>t){let n=C[L++],e=C[L++];if(0<(128&n)||0<(128&e))return void(L-=6);if(7>t)return G(s,a,r,u,n,e);let i=C[L++];return 0<(128&i)?void(L-=7):G(s,a,r,u,n,e,i)}else{let d=C[L++],e=C[L++],c=C[L++],f=C[L++];if(0<(128&d)||0<(128&e)||0<(128&c)||0<(128&f))return void(L-=8);if(10>t){if(8===t)return G(s,a,r,u,d,e,c,f);else{let t=C[L++];return 0<(128&t)?void(L-=9):G(s,a,r,u,d,e,c,f,t)}}else if(12>t){let n=C[L++],i=C[L++];if(0<(128&n)||0<(128&i))return void(L-=10);if(11>t)return G(s,a,r,u,d,e,c,f,n,i);let o=C[L++];return 0<(128&o)?void(L-=11):G(s,a,r,u,d,e,c,f,n,i,o)}else{let g=C[L++],i=C[L++],p=C[L++],h=C[L++];if(0<(128&g)||0<(128&i)||0<(128&p)||0<(128&h))return void(L-=12);if(!(14>t)){let l=C[L++],b=C[L++];if(0<(128&l)||0<(128&b))return void(L-=14);if(15>t)return G(s,a,r,u,d,e,c,f,g,i,p,h,l,b);let n=C[L++];return 0<(128&n)?void(L-=15):G(s,a,r,u,d,e,c,f,g,i,p,h,l,b,n)}if(12===t)return G(s,a,r,u,d,e,c,f,g,i,p,h);else{let t=C[L++];return 0<(128&t)?void(L-=13):G(s,a,r,u,d,e,c,f,g,i,p,h,t)}}}}}function d(e){return M.copyBuffers?// specifically use the copying slice (not the node one)
Uint8Array.prototype.slice.call(C,L,L+=e):C.subarray(L,L+=e)}function c(){var e=Math.exp;let t,n=C[L++],s=C[L++],a=(n<<8)+s,r=31&a>>10,i=1023&a;return t=0==r?e(i,-24):31==r?0==i?1/0:NaN:e(i+1024,r-25),32768&a?-t:t}function l(){let e=C[L++];if(96<=e&&120>e){if(e-=96,_>=L)// if it has been extracted, must use it (and faster anyway)
return P.slice(L-V,(L+=e)-V);if(!(0==_&&180>x))return $(e)}else return L--,n();let t,s=4095&(e<<5^(1<e?v.getUint16(L):0<e?C[L]:0)),a=H[s],r=L,d=L+e-3,c=0;if(a&&a.bytes==e){for(;r<d;){if(t=v.getUint32(r),t!=a[c++]){r=1879048192;break}r+=4}for(d+=3;r<d;)if(t=C[r++],t!=a[c++]){r=1879048192;break}if(r===d)return L=r,a.string;d-=3,r=L}for(a=[],H[s]=a,a.bytes=e;r<d;)t=v.getUint32(r),a.push(t),r+=4;for(d+=3;r<d;)t=C[r++],a.push(t);// for small blocks, avoiding the overhead of the extract call is helpful
let l=16>e?u(e):o(e);return null==l?a.string=$(e):a.string=l}function f(e,t){return"string"==typeof e?e+t:e instanceof Array?e.concat(t):Object.assign({},e,t)}function g(e,t){w[t]=n=>{if(!e)throw new Error("Could not find typed array for code "+t);// we have to always slice/copy here to get a new ArrayBuffer that is word/byte aligned
return new K[e](Uint8Array.prototype.slice.call(n,0).buffer)}}function p(e){let t=x,n=L,s=V,a=_,r=P,i=T,o=new Uint8Array(C.slice(0,x)),u=j,d=M,c=Y,l=e();return x=t,L=n,V=s,_=a,P=r,T=i,C=o,Y=c,j=u,M=d,v=new DataView(C.buffer,C.byteOffset,C.byteLength),l}function h(){C=null,T=null,j=null}function b(e){w[e.tag]=e.decode}// function copyBinary(source, target, targetOffset, offset, endOffset) {
// 	while (offset < endOffset) {
// 		target[targetOffset++] = source[offset++]
// 	}
// }
function y(e){24>e?be[Ie++]=128|e:256>e?(be[Ie++]=152,be[Ie++]=e):65536>e?(be[Ie++]=153,be[Ie++]=e>>8,be[Ie++]=255&e):(be[Ie++]=154,ye.setUint32(Ie,e),Ie+=4)}function m(e,t){if("string"==typeof e){if(3<e.length){if(-1<t.objectMap[e]||t.values.length>=t.maxValues)return;let n=t.get(e);if(n)2==++n.count&&t.values.push(e);else if(t.set(e,{count:1}),t.samplingPackedValues){let n=t.samplingPackedValues.get(e);n?n.count++:t.samplingPackedValues.set(e,{count:1})}}}else if(Array.isArray(e))for(let n=0,s=e.length;n<s;n++)m(e[n],t);else{let s=!t.encoder.useRecords;for(var n in e)e.hasOwnProperty(n)&&(s&&m(n,t),m(e[n],t))}}function I(e){return{tag:e,encode:function(e,t){let n=e.byteLength,s=e.byteOffset||0,a=e.buffer||e;t(/*hasNodeBuffer ? */Buffer.from(a,s,n)/* :
                            new Uint8Array(buffer, offset, length)*/)}}}function O(e,t){let n=e.byteLength;24>n?be[Ie++]=64+n:256>n?(be[Ie++]=88,be[Ie++]=n):65536>n?(be[Ie++]=89,be[Ie++]=n>>8,be[Ie++]=255&n):(be[Ie++]=90,ye.setUint32(Ie,n),Ie+=4),Ie+n>=be.length&&t(Ie+n),be.set(e,Ie),Ie+=n}function A(e,t){// insert the ids that need to be referenced for structured clones
let n,s=8*t.length,a=e.length-s;for(t.sort((e,t)=>e.offset>t.offset?1:-1);n=t.pop();){let t=n.offset,r=n.id;e.copyWithin(t+s,t,a),s-=8;let i=t+s;// uint32
e[i++]=217,e[i++]=156,e[i++]=73,e[i++]=26,e[i++]=r>>24,e[i++]=255&r>>16,e[i++]=255&r>>8,e[i++]=255&r,a=t}return e}function U(e){if(e.Class){if(!e.encode)throw new Error("Extension has no encode function");ce.unshift(e.Class),de.unshift(e)}b(e)}function*k(e,t){const n=new Ae(t);for(const s of e)yield n.encode(s)}async function*R(e,t){const n=new Ae(t);for await(const s of e)yield n.encode(s)}/**
             * Given an Iterable/Iterator input which yields buffers, returns an IterableIterator which yields sync decoded objects
             * Or, given an Async Iterable/Iterator which yields promises resolving in buffers, returns an AsyncIterableIterator.
             * @param {Iterable|Iterator|AsyncIterable|AsyncIterableIterator} bufferIterator
             * @param {object} [options] - Decoder options
             * @returns {IterableIterator|Promise.<AsyncIterableIterator}
             */(function(e){e[e.NEVER=0]="NEVER",e[e.ALWAYS=1]="ALWAYS",e[e.DECIMAL_ROUND=3]="DECIMAL_ROUND",e[e.DECIMAL_FIT=4]="DECIMAL_FIT"})(e.FLOAT32_OPTIONS||(e.FLOAT32_OPTIONS={}));let E;try{E=new TextDecoder}catch(e){}let C,x,L=0;const S=105,F={};let M,j,P,T,B,v,D,V=0,_=0,w=[],N=[],W={useRecords:!1,mapsAsObjects:!0},Y=!1;class z{constructor(e){e&&(!1===e.useRecords&&e.mapsAsObjects===void 0&&(e.mapsAsObjects=!0),e.getStructures&&!e.structures&&((e.structures=[]).uninitialized=!0)),Object.assign(this,e)}decode(e,n){if(C)// re-entrant execution, save the state and restore it after we do this decode
return p(()=>(h(),this instanceof z?this.decode(e,n):z.prototype.decode.call(W,e,n)));x=-1<n?n:e.length,L=0,_=0,P=null,C=e;// this provides cached access to the data view for a buffer if it is getting reused, which is a recommended
// technique for getting data from a database where it can be copied into an existing buffer instead of creating
// new ones
try{v=e.dataView||(e.dataView=new DataView(e.buffer,e.byteOffset,e.byteLength))}catch(t){if(C=null,e instanceof Uint8Array)throw t;throw new Error("Source must be a Uint8Array or Buffer but was a "+(e&&"object"==typeof e?e.constructor.name:typeof e))}if(this instanceof z){if(M=this,B=this.sharedValues&&(this.pack?Array(this.maxPrivatePackedValues||16).concat(this.sharedValues):this.sharedValues),this.structures)return j=this.structures,t();(!j||0<j.length)&&(j=[])}else M=W,(!j||0<j.length)&&(j=[]),B=null;return t()}decodeMultiple(e,n){let s,a=0;try{let r=e.length;Y=!0;let i=this?this.decode(e,r):se.decode(e,r);if(n){if(!1===n(i))return;for(;L<r;)if(a=L,!1===n(t()))return}else{for(s=[i];L<r;)a=L,s.push(t());return s}}catch(e){throw e.lastPosition=a,e.values=s,e}finally{Y=!1,h()}}}const q=/^[a-zA-Z_$][a-zA-Z\d_$]*$/;let $=r,G=String.fromCharCode,H=Array(4096);// let readString8 = readStringJS;
// let readString16 = readStringJS;
// let readString32 = readStringJS;
class J{constructor(e){this.value=e}}let K="object"==typeof window?window:global;w[0]=e=>new Date(e),w[1]=e=>new Date(1e3*e),w[2]=e=>new DataView(e.buffer,e.byteOffset,e.byteLength).getBigUint64(0),w[3]=e=>BigInt(-1)-new DataView(e.buffer,e.byteOffset,e.byteLength).getBigUint64(0);// the registration of the record definition extension (tag 105)
const Q=()=>{let e=n(),t=e[0],a=e[1];j[255&a]=t,t.read=s(t);let r={};for(let n,s=2,a=e.length;s<a;s++)n=t[s-2],r[n]=e[s];return r};Q.handlesRead=!0,w[105]=Q,w[27]=e=>(K[e[0]]||Error)(e[1],e[2]);const X=e=>{if(132!=C[L++])throw new Error("Packed values structure must be followed by 4 element array");let t=e();// packed values
return B=B?t.concat(B.slice(t.length)):t,B.prefixes=e(),B.suffixes=e(),e();// read the rump
};X.handlesRead=!0,w[51]=X,w[6]=e=>{if("number"==typeof e)return B[16+(0<=e?2*e:-2*e-1)];throw new Error("No support for non-integer packed references yet")},w[40009]=e=>{T||(T=new Map);let t=C[L];const s=4==t>>5?[]:{};// TODO: handle Maps, Sets, and other types that can cycle; this is complicated, because you potentially need to read
// ahead past references to record structure definitions
let a={target:s,used:!1};// a placeholder object
T.set(e,a);let r=n();// read the next value as the target object to id
return a.used?Object.assign(s,r):(a.target=r,r);// no cycle, can just use the returned read object
},w[40010]=e=>{// pointer extension (for structured clones)
let t=T.get(e);return t.used=!0,t.target},w[258]=e=>new Set(e);// https://github.com/input-output-hk/cbor-sets-spec/blob/master/CBOR_SETS.md
const Z=e=>(M.mapsAsObjects&&(M.mapsAsObjects=!1,D=!0),e());Z.handlesRead=!0,w[259]=Z,N.push((e,t)=>225<=e&&255>=e?f(B.prefixes[e-224],t):28704<=e&&32767>=e?f(B.prefixes[e-28672],t):1879052288<=e&&2147483647>=e?f(B.prefixes[e-1879048192],t):216<=e&&223>=e?f(t,B.suffixes[e-216]):27647<=e&&28671>=e?f(t,B.suffixes[e-27639]):1811940352<=e&&1879048191>=e?f(t,B.suffixes[e-1811939328]):void 0);const ee=["Uint8","Uint8Clamped","Uint16","Uint32","BigUint64","Int8","Int16","Int32","BigInt64","Float32","Float64"].map(e=>e+"Array"),te=[64,68,69,70,71,72,77,78,79,81,82];for(let t=0;t<ee.length;t++)g(ee[t],te[t]);const ne=Array(147);// this is a table matching binary exponents to the multiplier to determine significant digit rounding
for(let t=0;256>t;t++)ne[t]=+("1e"+Math.floor(45.15-.30103*t));let se=new z({useRecords:!1});const ae=se.decode,re=se.decodeMultiple;let ie,oe=new Float32Array(1),ue=new Uint8Array(oe.buffer,0,4);try{ie=new TextEncoder}catch(e){}let de,ce;// const hasNodeBuffer = typeof Buffer !== 'undefined';
const le=/*hasNodeBuffer ? */Buffer.allocUnsafeSlow/* : Uint8Array*/,fe=/*hasNodeBuffer ? */Buffer/* : Uint8Array*/,ge=105,pe=256,he=/*hasNodeBuffer ? */4294967296/* : 0x7fd00000*/;// let serializationId = 1;
let be,ye,me,Ie=0;const Oe=Symbol("record-id");class Ae extends z{constructor(e){super(e),this.offset=0;// this.offset = 0;
// let typeBuffer;
let t,n,s,a,r;e=e||{};let i=0,o=!!(ie&&ie.encodeInto)&&function(e,t){return ie.encodeInto(e,be.subarray(t)).written},u=this,d=64,c=e.sequential;// let encodeUtf8 = hasNodeBuffer ? Buffer : Uint8Array;
c&&(d=0,this.structures=[]);let l,f,g,p=e.sharedValues;if(p){g=Object.create(null);for(let e=0,t=p.length;e<t;e++)g[p[e]]=e}let h=[],b=0,I=0;this.encode=function(o,U){if(be||(be=le(8192),ye=new DataView(be.buffer,0,8192),Ie=0),me=be.length-10,2048>me-Ie?(be=le(be.length),ye=new DataView(be.buffer,0,be.length),me=be.length-10,Ie=0):U===Le&&(Ie=2147483640&Ie+7),t=Ie,r=u.structuredClone?new Map:null,n=u.structures,n){n.uninitialized&&(u.structures=n=u.getStructures());let e=n.length;if(e>d&&!c&&(e=d),!n.transitions){n.transitions=Object.create(null);for(let t,s=0;s<e;s++){if(t=n[s],!t)continue;let e,a=n.transitions;for(let n,s=0,r=t.length;s<r;s++)n=t[s],e=a[n],e||(e=a[n]=Object.create(null)),a=e;a[Oe]=s}i=n.length}c||(n.nextId=e)}if(s&&(s=!1),a=n||[],f=g,e.pack){let t=new Map;// @ts-ignore
if(t.values=[],t.encoder=u,t.maxValues=e.maxPrivatePackedValues||(g?16:1/0),t.objectMap=g||!1,t.samplingPackedValues=l,m(o,t),0<t.values.length){be[Ie++]=216,be[Ie++]=51,y(4);let e=t.values;O(e),y(0),y(0),f=Object.create(g||null);for(let t=0,n=e.length;t<n;t++)f[e[t]]=t}}try{// update the offset so next serialization doesn't write over our buffer, but can continue writing to same buffer sequentially
if(O(o),u.offset=Ie,r&&r.idsToInsert){Ie+=8*r.idsToInsert.length,Ie>me&&k(Ie),u.offset=Ie;let e=A(be.subarray(t,Ie),r.idsToInsert);return r=null,e}return U===Le?(be.start=t,be.end=Ie,be):be.subarray(t,Ie);// position can change if we call pack again in saveStructures, so we get the buffer now
}finally{if(n){if(10>I&&I++,1e4<b)n.transitions=null,I=0,b=0,0<h.length&&(h=[]);else if(0<h.length&&!c){for(let e=0,t=h.length;e<t;e++)h[e][Oe]=void 0;h=[]}if(s&&u.saveStructures){u.structures.length>d&&(u.structures=u.structures.slice(0,d));// we can't rely on start/end with REUSE_BUFFER_MODE since they will (probably) change when we save
let e=be.subarray(t,Ie),n=u.structures||[];return(p&&(n=n.concat(p)),!1===u.saveStructures(u.structures,i))?(u.structures=u.getStructures()||[],u.encode(o)):(i=n.length,e)}}}},this.findCommonStringsToPack=()=>(l=new Map,g||(g=Object.create(null)),({threshold:t})=>{t=t||4;let n=this.pack?e.maxPrivatePackedValues||16:0;p||(p=this.sharedValues=[]);for(let[e,a]of l)a.count>t&&(g[e]=n++,p.push(e),s=!0);l=null});const O=n=>{Ie>me&&(be=k(Ie));const s=typeof n;let a;if("string"==s){if(f){let t=f[n];if(0<=t)return void(16>t?be[Ie++]=t+224:(be[Ie++]=198,1&t?O(15-t>>1):O(t-16>>1)));/*						} else if (packedStatus.serializationId != serializationId) {
                                                                packedStatus.serializationId = serializationId
                                                                packedStatus.count = 1
                                                                if (options.sharedPack) {
                                                                    let sharedCount = packedStatus.sharedCount = (packedStatus.sharedCount || 0) + 1
                                                                    if (shareCount > (options.sharedPack.threshold || 5)) {
                                                                        let sharedPosition = packedStatus.position = packedStatus.nextSharedPosition
                                                                        hasSharedUpdate = true
                                                                        if (sharedPosition < 16)
                                                                            target[position++] = sharedPosition + 0xc0
                                    
                                                                    }
                                                                }
                                                            } // else any in-doc incrementation?*/if(l&&!e.pack){let e=l.get(n);e?e.count++:l.set(n,{count:1})}}let t,s=n.length;t=32>s?1:256>s?2:65536>s?3:5;let r=3*s;if(Ie+r>me&&(be=k(Ie+r)),64>s||!1===o){let e,r,i,o=Ie+t;for(e=0;e<s;e++)r=n.charCodeAt(e),128>r?be[o++]=r:2048>r?(be[o++]=192|r>>6,be[o++]=128|63&r):55296==(64512&r)&&56320==(64512&(i=n.charCodeAt(e+1)))?(r=65536+((1023&r)<<10)+(1023&i),e++,be[o++]=240|r>>18,be[o++]=128|63&r>>12,be[o++]=128|63&r>>6,be[o++]=128|63&r):(be[o++]=224|r>>12,be[o++]=128|63&r>>6,be[o++]=128|63&r);a=o-Ie-t}else// @ts-ignore
a=o(n,Ie+t,r);24>a?be[Ie++]=96|a:256>a?(2>t&&be.copyWithin(Ie+2,Ie+1,Ie+1+a),be[Ie++]=120,be[Ie++]=a):65536>a?(3>t&&be.copyWithin(Ie+3,Ie+2,Ie+2+a),be[Ie++]=121,be[Ie++]=a>>8,be[Ie++]=255&a):(5>t&&be.copyWithin(Ie+5,Ie+3,Ie+3+a),be[Ie++]=122,ye.setUint32(Ie,a),Ie+=4),Ie+=a}else if("number"===s){if(n>>>0===n)24>n?be[Ie++]=n:256>n?(be[Ie++]=24,be[Ie++]=n):65536>n?(be[Ie++]=25,be[Ie++]=n>>8,be[Ie++]=255&n):(be[Ie++]=26,ye.setUint32(Ie,n),Ie+=4);else if(n>>0===n)-24<=n?be[Ie++]=31-n:-256<=n?(be[Ie++]=56,be[Ie++]=~n):-65536<=n?(be[Ie++]=57,ye.setUint16(Ie,~n),Ie+=2):(be[Ie++]=58,ye.setUint32(Ie,~n),Ie+=4);else{let e;if(0<(e=this.useFloat32)&&4294967296>n&&-2147483648<=n){be[Ie++]=250,ye.setFloat32(Ie,n);let t;if(4>e||// this checks for rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved
(t=n*ne[(127&be[Ie])<<1|be[Ie+1]>>7])>>0===t)return void(Ie+=4);Ie--}be[Ie++]=251,ye.setFloat64(Ie,n),Ie+=8}}else if("object"===s){if(!n)be[Ie++]=246;else{if(r){let e=r.get(n);if(e){if(!e.id){let t=r.idsToInsert||(r.idsToInsert=[]);e.id=t.push(e)}return be[Ie++]=217,be[Ie++]=156,be[Ie++]=74,be[Ie++]=26,ye.setUint32(Ie,e.id),void(Ie+=4)}r.set(n,{offset:Ie-t})}let e=n.constructor;if(e===Object)U(n,!0);else if(e===Array){a=n.length,24>a?be[Ie++]=128|a:y(a);for(let e=0;e<a;e++)O(n[e])}else if(e===Map){(this.mapsAsObjects?!1!==this.useTag259ForMaps:this.useTag259ForMaps)&&(be[Ie++]=217,be[Ie++]=1,be[Ie++]=3),a=n.size,24>a?be[Ie++]=160|a:256>a?(be[Ie++]=184,be[Ie++]=a):65536>a?(be[Ie++]=185,be[Ie++]=a>>8,be[Ie++]=255&a):(be[Ie++]=186,ye.setUint32(Ie,a),Ie+=4);for(let[e,t]of n)O(e),O(t)}else{for(let e,t=0,s=de.length;t<s;t++)if(e=ce[t],n instanceof e){let e=de[t],s=e.tag;return 24>s?be[Ie++]=192|s:256>s?(be[Ie++]=216,be[Ie++]=s):65536>s?(be[Ie++]=217,be[Ie++]=s>>8,be[Ie++]=255&s):-1<s&&(be[Ie++]=218,ye.setUint32(Ie,s),Ie+=4),void e.encode.call(this,n,O,k)}if(n[Symbol.iterator]){be[Ie++]=159;// indefinite length array
for(let e of n)O(e);// stop-code
return void(be[Ie++]=255)}// no extension found, write as object
U(n,!n.hasOwnProperty)}}}else if("boolean"===s)be[Ie++]=n?245:244;else if("bigint"===s){if(n<BigInt(1)<<BigInt(64)&&0<=n)be[Ie++]=27,ye.setBigUint64(Ie,n);else if(n>-(BigInt(1)<<BigInt(64))&&0>n)be[Ie++]=59,ye.setBigUint64(Ie,-n-BigInt(1));else// overflow
if(this.largeBigIntToFloat)be[Ie++]=251,ye.setFloat64(Ie,+n);else throw new RangeError(n+" was too large to fit in CBOR 64-bit integer format, set largeBigIntToFloat to convert to float-64");Ie+=8}else if("undefined"===s)be[Ie++]=247;else throw new Error("Unknown type: "+s)},U=!1===this.useRecords?this.variableMapSize?e=>{// this method is slightly slower, but generates "preferred serialization" (optimally small for smaller objects)
let t=Object.keys(e),n=t.length;24>n?be[Ie++]=160|n:256>n?(be[Ie++]=184,be[Ie++]=n):65536>n?(be[Ie++]=185,be[Ie++]=n>>8,be[Ie++]=255&n):(be[Ie++]=186,ye.setUint32(Ie,n),Ie+=4);let s;for(let a=0;a<n;a++)O(s=t[a]),O(e[s])}:(e,n)=>{be[Ie++]=185;// always use map 16, so we can preallocate and set the length afterwards
let s=Ie-t;Ie+=2;let a=0;for(let t in e)(n||e.hasOwnProperty(t))&&(O(t),O(e[t]),a++);be[s++ +t]=a>>8,be[s+t]=255&a}:/*	sharedStructures ?  // For highly stable structures, using for-in can a little bit faster
                            (object, safePrototype) => {
                                let nextTransition, transition = structures.transitions || (structures.transitions = Object.create(null))
                                let objectOffset = position++ - start
                                let wroteKeys
                                for (let key in object) {
                                    if (safePrototype || object.hasOwnProperty(key)) {
                                        nextTransition = transition[key]
                                        if (!nextTransition) {
                                            nextTransition = transition[key] = Object.create(null)
                                            nextTransition.__keys__ = (transition.__keys__ || []).concat([key])
                                            /*let keys = Object.keys(object)
                                            if
                                            let size = 0
                                            let startBranch = transition.__keys__ ? transition.__keys__.length : 0
                                            for (let i = 0, l = keys.length; i++) {
                                                let key = keys[i]
                                                size += key.length << 2
                                                if (i >= startBranch) {
                                                    nextTransition = nextTransition[key] = Object.create(null)
                                                    nextTransition.__keys__ = keys.slice(0, i + 1)
                                                }
                                            }
                                            makeRoom(position + size)
                                            nextTransition = transition[key]
                                            target.copy(target, )
                                            objectOffset
                                        }
                                        transition = nextTransition
                                        encode(object[key])
                                    }
                                }
                                let id = transition.id
                                if (!id) {
                                    id = transition.id = structures.push(transition.__keys__) + 63
                                    if (sharedStructures.onUpdate)
                                        sharedStructures.onUpdate(id, transition.__keys__)
                                }
                                target[objectOffset + start] = id
                            }*/e=>{let t,r=Object.keys(e),o=a.transitions||(a.transitions=Object.create(null)),u=0,c=r.length;for(let n,s=0;s<c;s++)n=r[s],t=o[n],t||(t=o[n]=Object.create(null),u++),o=t;let l=o[Oe];if(void 0!==l)// tag two byte
be[Ie++]=217,be[Ie++]=ge,be[Ie++]=l;else if(l=a.nextId++,l||(l=0,a.nextId=1),l>=pe&&(a.nextId=(l=d)+1),o[Oe]=l,a[l]=r,n&&n.length<=d)// tag two byte
// tag number
be[Ie++]=217,be[Ie++]=ge,be[Ie++]=l,s=!0;else{be[Ie++]=216,be[Ie++]=ge,u&&(b+=I*u),h.length>=pe-d&&(h.shift()[Oe]=void 0),h.push(o),y(c+2),O(r),be[Ie++]=25,be[Ie++]=ge,be[Ie++]=l;// now write the values
for(let t=0;t<c;t++)O(e[r[t]]);return}24>c?be[Ie++]=128|c:y(c);for(let t=0;t<c;t++)O(e[r[t]])},k=e=>{var n=Math.min,s=Math.round,a=Math.max;let r;if(16777216<e){// special handling for really large buffers
if(e-t>he)throw new Error("Encoded buffer would be larger than maximum buffer size");r=n(he,4096*s(a((e-t)*(67108864<e?1.25:2),4194304)/4096))}else// faster handling for smaller buffers
r=(a(e-t<<2,be.length-1)>>12)+1<<12;let i=le(r);return ye=new DataView(i.buffer,0,r),be.copy?be.copy(i,0,t,e):i.set(be.slice(t,e)),Ie-=t,t=0,me=i.length-10,be=i}}useBuffer(e){// this means we are finished using our own buffer and we can write over it safely
be=e,ye=new DataView(be.buffer,be.byteOffset,be.byteLength),Ie=0}}ce=[Date,Set,Error,RegExp,ArrayBuffer,fe,Uint8Array,Uint8ClampedArray,Uint16Array,Uint32Array,"undefined"==typeof BigUint64Array?function(){}:BigUint64Array,Int8Array,Int16Array,Int32Array,"undefined"==typeof BigInt64Array?function(){}:BigInt64Array,Float32Array,Float64Array],de=[{tag:1,encode(e){let t=e.getTime()/1e3;(this.useTimestamp32||0===e.getMilliseconds())&&0<=t&&4294967296>t?(be[Ie++]=26,ye.setUint32(Ie,t),Ie+=4):(be[Ie++]=251,ye.setFloat64(Ie,t),Ie+=8)}},{tag:258,encode(e,t){let n=Array.from(e);t(n)}},{tag:27,encode(e,t){t([e.name,e.message])}},{tag:27,encode(e,t){t(["RegExp",e.source,e.flags])}},{encode(e,t,n){O(e,n)}},{encode(e,t,n){O(e,n)}},I(64),I(68),I(69),I(70),I(71),I(72),I(77),I(78),I(79),I(81),I(82)];let Ue=new Ae({useRecords:!1});const ke=Ue.encode,{NEVER:Re,ALWAYS:Ee,DECIMAL_ROUND:Ce,DECIMAL_FIT:xe}=e.FLOAT32_OPTIONS,Le=1e3;e.ALWAYS=Ee,e.DECIMAL_FIT=xe,e.DECIMAL_ROUND=Ce,e.Decoder=z,e.Encoder=Ae,e.NEVER=Re,e.REUSE_BUFFER_MODE=Le,e.Tag=J,e.addExtension=U,e.clearSource=h,e.decode=ae,e.decodeIter=function(e,t={}){if(!e||"object"!=typeof e)throw new Error("first argument must be an Iterable, Async Iterable, Iterator, Async Iterator, or a promise");const n=new z(t);let s;const a=e=>{let t;// if there's incomplete data from previous chunk, concatinate and try again
s&&(e=Buffer.concat([s,e]),s=void 0);try{t=n.decodeMultiple(e,void 0)}catch(n){if(n.incomplete)s=e.slice(n.lastPosition),t=n.values;else throw n}return t};if("function"==typeof e[Symbol.iterator])return function*(){for(const t of e)yield*a(t)}();return"function"==typeof e[Symbol.asyncIterator]?async function*(){for await(const t of e)yield*a(t)}():void 0},e.decodeMultiple=re,e.encode=ke,e.encodeIter=/**
             * Given an Iterable first argument, returns an Iterable where each value is encoded as a Buffer
             * If the argument is only Async Iterable, the return value will be an Async Iterable.
             * @param {Iterable|Iterator|AsyncIterable|AsyncIterator} objectIterator - iterable source, like a Readable object stream, an array, Set, or custom object
             * @param {options} [options] - cbor-x Encoder options
             * @returns {IterableIterator|Promise.<AsyncIterableIterator>}
             */function(e,t={}){if(!e||"object"!=typeof e)throw new Error("first argument must be an Iterable, Async Iterable, or a Promise for an Async Iterable");else{if("function"==typeof e[Symbol.iterator])return k(e,t);if("function"==typeof e.then||"function"==typeof e[Symbol.asyncIterator])return R(e,t);throw new Error("first argument must be an Iterable, Async Iterable, Iterator, Async Iterator, or a Promise")}},e.isNativeAccelerationEnabled=!1,e.mapsAsObjects=!0,e.roundFloat32=function(e){oe[0]=e;let t=ne[(127&ue[3])<<1|ue[2]>>7];return(t*e+(0<e?.5:-.5)>>0)/t},e.useRecords=!1,Object.defineProperty(e,"__esModule",{value:!0})})})});
